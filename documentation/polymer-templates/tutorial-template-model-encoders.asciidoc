---
title: Using Model Encoders with a PolymerTemplate Model
order: 9
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
= Using Model Encoders with a PolymerTemplate Model

The `@Encode` annotation allows you to encode a property with a `Long` value to a `String` value, before sending it to the client side. When the client side sends the value back, it is once again encoded back to a `Long` value.

This is useful in many scenarios, for example:

* When using ready-made beans that are typically delivered as binary class files. You have no control over the content and the structure may also be inappropriate for use in a template model used in a UI representation. 

* If you use a database backend with JPA entities and need to reference an identifier on the client side, for whatever reason. The entities usually have unique identifiers of the type `Long` that is not supported by Vaadin Flow. 

You can encode any type (supported and unsupported) to a supported type. 

*Example*: Using the `Encode` annotation in the `Person` JPA entity class that includes a model class.

[source,java]
----
@Entity
public class Person implements Serializable {
    @Id
    @GeneratedValue
    private Long id;

    public Long getId() {
        return id;
    }

}

public interface MyModel extends TemplateModel {
   @Encode(value=LongToStringEncoder.class, path="id")
   void setPerson(Person person);
   Person getPerson();
}
----
* The annotation parameter, `path="id"`, is used to address the `id` sub property of the `person` property. By default, the `path` value is `""`, which means that an encoder is applied to the property itself.

*Example*: `LongToStringEncoder` class.
[source,java]
----
public class LongToStringEncoder implements ModelEncoder<Long, String> {

    @Override
    public String encode(Long modelValue) {
        return Optional.ofNullable(modelValue).map(Object::toString)
                .orElse(null);
    }

    @Override
    public Long decode(String presentationValue) {
        return Optional.ofNullable(presentationValue).map(Long::valueOf)
                .orElse(null);
    }

}
----

On the client side, the `id` property of the `Person` bean is now the `String` type, and you can access it in your code in the usual way.  

== Using @Encode to Split Property Values

Another use case for encoders, is to split one property value into several sub properties, and then use the sub properties in different UI fields. For example, a `birthday` property could be split into `day`, `month` and `year` sub properties.

*Example*: `Date` property in the `MyModel` template model.

[source,java]
----
public interface MyModel extends TemplateModel {

    Date getBirthDate();

    @Encode(DateToDateBeanEncoder.class)
    void setBirthDate(Date birthDate);
}
----

*Example*: `DateBean` bean definition.

[source,java]
----
public class DateBean implements Serializable {

    private String day;
    private String month;
    private String year;

    public String getDay() {
        return day;
    }

    public void setDay(String day) {
        this.day = day;
    }

    public String getMonth() {
        return month;
    }

    public void setMonth(String month) {
        this.month = month;
    }

    public String getYear() {
        return year;
    }

    public void setYear(String year) {
        this.year = year;
    }

}
----

*Example*: `DateToDateBeanEncoder` encoder class. 

[source,java]
----
public class DateToDateBeanEncoder implements ModelEncoder<Date, DateBean> {

    @Override
    public DateBean encode(Date modelValue) {
        if (modelValue == null) {
            return null;
        }
        DateBean bean = new DateBean();
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.setTime(modelValue);
        bean.setDay(Integer.toString(calendar.get(Calendar.DAY_OF_MONTH)));
        bean.setMonth(Integer.toString(calendar.get(Calendar.MONTH) + 1));
        bean.setYear(Integer.toString(calendar.get(Calendar.YEAR)));
        return bean;
    }

    @Override
    public Date decode(DateBean presentationValue) {
        if (presentationValue == null) {
            return null;
        }
        int year = Integer.parseInt(presentationValue.getYear());
        int day = Integer.parseInt(presentationValue.getDay());
        int month = Integer.parseInt(presentationValue.getMonth()) - 1;
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.set(year, month, day);
        return calendar.getTime();
    }

}
----
* The `Date` property is encoded into 3 sub properties: `day`, `month` and `year`.

You can now use the following snippet in your Polymer component template.

*Example*: `day`, `month` and `year` definition a Polymer template (_snippet only_). 

[source,js]
----
static get template() {
    return html`
        <div style="width: 200px;">
            <label>Birth date:</label>
            <label for="day">Enter your birthday:</label><paper-input id="day" value="{{birthDate.day}}"></paper-input>
            <label for="month">Enter the month of your birthday:</label><paper-input id="month" value="{{birthDate.month}}"></paper-input>
            <label for="year">Enter the year of your birthday:</label><paper-input id="year" value="{{birthDate.year}}"></paper-input>
            <button on-click="commit" id="commit">Commit</button>
        </div>`;
}
----
* Each sub property is editable on the client side, but on the server side they are a single property, `birthDate`.
* You need to use the original property name, `birthDate` in this example, to access the sub properties. The original property name (and not the bean name, `dateBean`) is used as the prefix. 
